# 개별 사용자 권한 제어 설계 (Fine-Grained Access Control)

이 문서는 역할 기반 접근 제어(RBAC)를 기반으로, 사용자 개개인에게 특정 도구(Tool)나 파일(Document)에 대한 접근 권한을 개별적으로 부여하는 세분화된 권한 관리 시스템(하이브리드 모델)의 설계 방법을 설명합니다.

## 핵심 아이디어: 역할(Role)과 개별 권한(Individual Permission)의 결합

- **역할 (Role)**: 대다수 사용자에게 적용되는 **기본 권한 템플릿**입니다. (예: 'Admin', 'Editor', 'Member') 관리를 단순화하고 일관성을 유지합니다.
- **개별 권한 (Individual Permission)**: 특정 사용자에게만 부여되는 **예외적인 권한**입니다. 다대다(Many-to-Many) 관계를 통해 구현하며, 최고 수준의 유연성을 제공합니다.

**최종 권한 = 역할의 기본 권한 ∪ 개별적으로 부여된 권한**

---

## 1. 개별 "도구(Tool)" 사용 권한 부여 방법

사용자가 속한 워크스페이스의 역할(Role)이 허용하는 기본 도구 외에, 특정 도구를 추가로 사용할 수 있도록 허용하는 방법입니다.

### 단계 1: `Tool` 모델 정의

시스템에서 사용 가능한 모든 도구를 데이터베이스에서 관리할 수 있도록 모델을 생성합니다. 이를 통해 동적으로 도구를 추가하고 관리할 수 있습니다.

**`llm_services/models.py`**
```python
from django.db import models

class Tool(models.Model):
    name = models.CharField(max_length=100, unique=True, help_text="도구의 고유한 이름 (예: read_file, write_file)")
    description = models.TextField(blank=True, help_text="도구에 대한 설명 및 사용법")

    def __str__(self):
        return self.name
```
*이 모델을 생성한 후, 관리자 페이지나 초기 데이터 로딩(fixture)을 통해 시스템에 존재하는 `read_file`, `write_file` 등의 도구를 데이터로 추가해야 합니다.*

### 단계 2: `WorkspaceMember`에 다대다(M2M) 관계 추가

`WorkspaceMember` 모델이 여러 `Tool`에 대한 개별 권한을 가질 수 있도록 `ManyToManyField`를 추가합니다.

**`workspaces/models.py`**
```python
from django.db import models

class WorkspaceMember(models.Model):
    # ... 기존 필드 (user, workspace, role 등) ...

    # 역할(Role) 기본 권한 외에 개별적으로 허용된 도구 목록
    explicitly_allowed_tools = models.ManyToManyField(
        'llm_services.Tool',  # 순환 참조 방지를 위해 문자열로 모델 지정
        blank=True,
        related_name="authorized_members",
        help_text="역할 권한 외에 개별적으로 허용된 도구"
    )
```

### 단계 3: 최종 권한 확인 로직 수정

에이전트를 생성할 때, 사용자의 역할 권한과 개별 권한을 모두 합쳐 최종 도구 목록을 계산합니다.

**`permissions.py` (또는 `agents.py`)**
```python
from .tools import AVAILABLE_TOOLS
from .workspaces.models import WorkspaceMember

# 역할별 기본 허용 도구 이름 목록
ROLE_PERMISSIONS = {
    "ADMIN": ["read_file", "write_file", "run_shell_command"],
    "EDITOR": ["read_file", "write_file"],
    "MEMBER": ["read_file"],
}

def get_tools_for_member(member: WorkspaceMember) -> list:
    """워크스페이스 멤버의 역할과 개별 권한을 종합하여 최종 허용 도구 목록을 반환합니다."""
    
    # 1. 역할(Role)에 따른 기본 허용 도구 이름 집합(set)
    role_tool_names = set(ROLE_PERMISSIONS.get(member.role, []))

    # 2. 개별적으로 허용된 도구 이름 집합(set)
    #    데이터베이스 쿼리를 통해 M2M 관계에 있는 Tool들의 이름을 가져옵니다.
    individual_tool_names = set(member.explicitly_allowed_tools.values_list('name', flat=True))

    # 3. 두 권한 집합을 합칩니다 (union 연산).
    final_tool_names = role_tool_names.union(individual_tool_names)

    # 4. 이름에 해당하는 실제 도구 함수(객체) 리스트를 반환합니다.
    return [AVAILABLE_TOOLS[name] for name in final_tool_names if name in AVAILABLE_TOOLS]
```

---

## 2. 개별 "파일(Document)" 접근 권한 부여 방법

기본적으로 워크스페이스의 모든 파일에 접근할 수 있거나 없도록 설정된 사용자가, 특정 파일에 대해서만 예외적으로 접근 권한을 갖도록 하는 방법입니다.

### 단계 1: `WorkspaceMember`에 다대다(M2M) 관계 추가

`WorkspaceMember`가 여러 `WorkspaceDocument`에 대한 개별 접근 권한을 가질 수 있도록 `ManyToManyField`를 추가합니다.

**`workspaces/models.py`**
```python
from django.db import models

class WorkspaceMember(models.Model):
    # ... 기존 필드 ...
    # ... explicitly_allowed_tools 필드 ...

    # 개별적으로 접근이 허용된 특정 문서 목록
    allowed_documents = models.ManyToManyField(
        'llm_services.WorkspaceDocument',
        blank=True,
        related_name="authorized_members",
        help_text="개별적으로 접근이 허용된 문서"
    )
```

### 단계 2: 파일 접근 제어 로직 구현

파일을 다루는 로직(API 뷰, 도구 함수 등) 내부에서 사용자가 해당 파일에 대한 접근 권한이 있는지 반드시 확인해야 합니다.

**예시: 보안이 강화된 파일 읽기 도구 함수**
```python
# tools.py

from .workspaces.models import WorkspaceMember
from .llm_services.models import WorkspaceDocument

def secure_read_file(member: WorkspaceMember, document_id: int) -> str:
    """사용자가 특정 파일에 접근 권한이 있는지 확인하고 내용을 반환합니다."""
    try:
        # 1. 문서가 존재하는지, 그리고 사용자가 속한 워크스페이스의 문서인지 확인합니다.
        document = WorkspaceDocument.objects.get(id=document_id, workspace=member.workspace)
    except WorkspaceDocument.DoesNotExist:
        return "오류: 문서를 찾을 수 없거나 다른 워크스페이스의 문서입니다."

    # 2. 권한 확인: 관리자이거나, 개별 허용 목록에 문서가 포함되어 있는지 확인합니다.
    is_admin = member.role == 'ADMIN'
    has_individual_permission = member.allowed_documents.filter(id=document.id).exists()

    if not (is_admin or has_individual_permission):
        return f"오류: 문서 '{document.description}'에 접근할 권한이 없습니다."

    # 3. 모든 검사를 통과하면 파일 내용을 반환합니다.
    # ... 실제 파일 시스템에서 파일 내용을 읽는 로직 ...
    return f"'{document.description}'의 내용: ..."
```

---

## 종합 및 장단점

- **구조**: 역할(Role)로 기본 권한을 설정하고, 개별 권한(M2M)으로 예외를 처리하는 하이브리드 모델입니다.
- **장점**:
    - **최고 수준의 유연성**: "모든 멤버는 읽기만 가능하지만, A 멤버는 특정 보고서 파일에 쓰기 권한도 가진다"와 같은 복잡한 정책을 완벽하게 구현할 수 있습니다.
    - **명시적이고 안전한 권한 관리**: 누가 어떤 리소스에 접근 가능한지 데이터베이스에 명확하게 기록되어 추적과 감사가 용이합니다.
- **단점**:
    - **관리 복잡성 증가**: 개별 권한을 부여하고 회수할 수 있는 관리자용 UI/UX가 반드시 필요합니다.
    - **쿼리 복잡성 증가**: 권한 확인 시 여러 테이블을 JOIN해야 하므로, 대규모 시스템에서는 성능 최적화를 고려해야 할 수 있습니다. (대부분의 경우 Django ORM이 효율적으로 처리합니다.)
